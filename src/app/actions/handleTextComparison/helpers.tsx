import { client } from "@/lib/openai";

export function jaccardSimilarity(a: string, b: string): number {
  // tokenize using preprocessLegal
  const setA = new Set(preprocessLegal(a));
  const setB = new Set(preprocessLegal(b));

  const intersection = new Set([...setA].filter((x) => setB.has(x)));
  const union = new Set([...setA, ...setB]);

  return union.size === 0 ? 0 : intersection.size / union.size;
}

export function preprocessLegal(text: string) {
  const legalStopwords = new Set([
    "section",
    "sec",
    "subsection",
    "title",
    "chapter",
    "act",
    "law",
    "rule",
    "rules",
    "regulation",
    "code",
    "statute",
    "part",
    "division",
    "article",
    "para",
    "paragraph",
    "of",
    "the",
    "and",
    "a",
    "an",
    "in",
    "for",
    "to",
  ]);

  return (text.toLowerCase().match(/[a-z0-9§\.]+|\([a-z0-9]+\)/g) || []).filter(
    (token) => !legalStopwords.has(token)
  );
}

/*
**** 
* /[a-z0-9§\.]+|\([a-z0-9]+\)/g
****
*
* [a-z0-9§\.]+
*	•	[...] → character class: match any one of the listed characters.
*	•	a-z → lowercase letters.
*	•	0-9 → digits.
*	•	§ → the section symbol (legal citations often use it).
*	•	\. → a literal period (so u.s.c. doesn’t get broken apart).
*	•	+ → one or more of the above.
*
*  This part matches tokens like:
*	•	"42"
*	•	"u.s.c."
*	•	"1396p"
*	•	"§"
⸻

* 2. \([a-z0-9]+\)
*	•	\( and \) → match literal parentheses.
*	•	[a-z0-9]+ → one or more letters/digits inside.
*	•	Together → captures things like (c), (a1), (12).
* ⸻
*
* 3. | (OR)
*
* The regex will match either a sequence of [a-z0-9§\.]+ or a parenthesized group like (c).
*
*⸻
*
* 4. g flag
*	•	“global” → don’t stop at the first match; return all matches.
*/

export function cosineSimilarityFromVectors(
  vecA: number[],
  vecB: number[]
): number {
  if (vecA.length !== vecB.length) {
    throw new Error("Embedding vectors must be of the same length");
  }
  let dotProduct = 0;
  let magA = 0;
  let magB = 0;
  for (let i = 0; i < vecA.length; i++) {
    dotProduct += vecA[i] * vecB[i];
    magA += vecA[i] * vecA[i];
    magB += vecB[i] * vecB[i];
  }
  if (magA === 0 || magB === 0) return 0;
  return dotProduct / (Math.sqrt(magA) * Math.sqrt(magB));
}

export const textSimilarityInstruction = `Compare the following two citations:
- The first citation ("Gold citation") is the ground truth.
- The second citation is generated by an AI model.
Your task is to assess how correct and similar the AI-generated citation is to the Gold citation.
Respond ONLY with a valid JSON object (no extra text or markdown), in the following format:
{
  "score": number, // A similarity score between 0 (completely dissimilar) and 1 (identical)
  "reasoning": string // Briefly explain your score and reasoning.
}`;

export async function getEmbedding(text: string) {
  const response = await client.embeddings.create({
    model: "text-embedding-3-small",
    input: text,
  });

  return response.data[0].embedding;
}
